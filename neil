#!/usr/bin/env bb
;; -*- mode: clojure -*-

;; DO NOT EDIT DIRECTLY. GENERATED FROM scr/babashka/neil.clj

(require '[babashka.deps :as deps])

(deps/add-deps '{:deps {borkdude/rewrite-edn {:mvn/version "0.2.0"}
                        org.babashka/spec.alpha {:git/url "https://github.com/babashka/spec.alpha"
                                                 :git/sha "1a841c4cc1d4f6dab7505a98ed2d532dd9d56b78"}
                        io.github.seancorfield/deps-new {:git/tag "v0.4.13" :git/sha "879c4eb"}
                        org.babashka/cli
                        #_{:local/root "/Users/borkdude/dev/cli"}
                        {:mvn/version "0.3.33"}}})

(ns babashka.neil.curl
  {:no-doc true}
  (:require
   [babashka.curl :as curl]
   [babashka.fs :as fs]
   [cheshire.core :as cheshire]))

(import java.net.URLEncoder)

(defn url-encode [s] (URLEncoder/encode s "UTF-8"))

(def curl-opts
  {:throw false
   :compressed (not (fs/windows?))})

(defn curl-get-json [url]
  (-> (curl/get url curl-opts)
      :body (cheshire/parse-string true)))

(ns babashka.neil.git
  {:no-doc true}
  (:require [babashka.neil.curl :refer [curl-get-json]]
            [clojure.string :as str]))

(defn default-branch [lib]
  (get (curl-get-json (format "https://api.github.com/repos/%s/%s"
                              (namespace lib) (name lib)))
       :default_branch))

(defn clean-github-lib [lib]
  (let [lib (str/replace lib "com.github." "")
        lib (str/replace lib "io.github." "")
        lib (symbol lib)]
    lib))

(defn latest-github-sha [lib]
  (let [lib (clean-github-lib lib)
        branch (default-branch lib)]
    (get (curl-get-json (format "https://api.github.com/repos/%s/%s/commits/%s"
                                (namespace lib) (name lib) branch))
         :sha)))

(defn list-github-tags [lib]
  (let [lib (clean-github-lib lib)]
    (curl-get-json (format "https://api.github.com/repos/%s/%s/tags"
                           (namespace lib) (name lib)))))

(defn latest-github-tag [lib]
  (-> (list-github-tags lib)
      first))

(defn find-github-tag [lib tag]
  (->> (list-github-tags lib)
       (filter #(= (:name %) tag))
       first))

(ns babashka.neil.rewrite
  (:require [clojure.string :as str]))

(defn indent [s n]
  (let [spaces (apply str (repeat n " "))
        lines (str/split-lines s)]
    (str/join "\n" (map (fn [s]
                          (if (str/blank? s) s
                              (str spaces s))) lines))))

(defn clean-trailing-whitespace [s]
  (str/join "\n" (map str/trimr (str/split-lines s))))

(ns babashka.neil.project
  (:require
   [babashka.fs :as fs]
   [borkdude.rewrite-edn :as r]
   [clojure.edn :as edn]))

(defn resolve-deps-file [dir deps-file]
  (if dir
    (fs/file dir deps-file)
    deps-file))

(defn ensure-neil-project [{:keys [dir deps-file]}]
  (let [deps-file (resolve-deps-file dir deps-file)
        deps-edn (slurp deps-file)
        edn (edn/read-string deps-edn)]
    (when-not (some-> edn :aliases :neil :project)
      (let [existing-aliases (:aliases edn)
            edn-nodes (r/parse-string deps-edn)
            edn-nodes (cond-> edn-nodes
                        (not (:aliases edn))
                        (r/assoc :aliases (r/parse-string "\n  {}"))
                        (contains? existing-aliases :neil)
                        (r/assoc-in [:aliases :neil] (r/parse-string "\n  {}"))
                        (not (some-> edn :aliases :neil :project))
                        (r/assoc-in [:aliases :neil :project]
                                    {}))]
        (spit deps-file (str edn-nodes))))))

(defn assoc-project-meta!
  "Updates deps-file's :neil :project `k` with `v`"
  [{:keys [dir deps-file k v]
    :as opts}]
  (ensure-neil-project opts)
  (let [deps-file (resolve-deps-file dir deps-file)
        deps-edn (slurp deps-file)
        nodes (r/parse-string deps-edn)
        nodes (r/assoc-in nodes [:aliases :neil :project k] v)]
    (spit deps-file (str nodes))))

(defn project-name [{:keys [deps-file]}]
  (-> (edn/read-string (slurp deps-file))
      :aliases :neil :project :name))

(defn coerce-project-name [pn]
  (let [sym (symbol pn)]
    (if (qualified-symbol? sym)
      sym
      (symbol (str pn) (str pn)))))

(ns babashka.neil.new
  {:no-doc true}
  (:require
   [babashka.neil.git :as git]
   [babashka.neil.project :as proj]
   [clojure.edn :as edn]
   [clojure.set :as set]
   [clojure.string :as str]))

(defn- built-in-template?
  "Returns true if the template name maps to a function in org.corfield.new."
  [template]
  (contains? (set (map name (keys (ns-publics 'org.corfield.new)))) template))

(defn- github-repo-http-url [lib]
  (str "https://github.com/" (git/clean-github-lib lib)))

(def github-repo-ssh-regex #"^git@github.com:([^/]+)/([^\.]+)\.git$")
(def github-repo-http-regex #"^https://github.com/([^/]+)/([^\.]+)(\.git)?$")

(defn- parse-git-url [git-url]
  (let [[[_ gh-user repo-name]] (or (re-seq github-repo-ssh-regex git-url)
                                    (re-seq github-repo-http-regex git-url))]
    (if (and gh-user repo-name)
      {:gh-user gh-user :repo-name repo-name}
      (throw (ex-info "Failed to parse :git/url" {:git/url git-url})))))

(defn- git-url->lib-sym [git-url]
  (when-let [{:keys [gh-user repo-name]} (parse-git-url git-url)]
    (symbol (str "io.github." gh-user) repo-name)))

(def lib-opts->template-deps-fn
  "A map to define valid CLI options for deps-new template deps.

  - Each key is a sequence of valid combinations of CLI opts.
  - Each value is a function which returns a tools.deps lib map."
  {[#{:local/root}]
   (fn [lib-sym lib-opts]
     {lib-sym (select-keys lib-opts [:local/root])})

   [#{} #{:git/url}]
   (fn [lib-sym lib-opts]
     (let [url (or (:git/url lib-opts) (github-repo-http-url lib-sym))
           {:keys [name commit]} (git/latest-github-tag (git-url->lib-sym url))]
       {lib-sym {:git/url url :git/tag name :git/sha (:sha commit)}}))

   [#{:git/tag} #{:git/url :git/tag}]
   (fn [lib-sym lib-opts]
     (let [url (or (:git/url lib-opts) (github-repo-http-url lib-sym))
           tag (:git/tag lib-opts)
           {:keys [commit]} (git/find-github-tag (git-url->lib-sym url) tag)]
       {lib-sym {:git/url url :git/tag tag :git/sha (:sha commit)}}))

   [#{:git/sha} #{:git/url :git/sha}]
   (fn [lib-sym lib-opts]
     (let [url (or (:git/url lib-opts) (github-repo-http-url lib-sym))
           sha (:git/sha lib-opts)]
       {lib-sym {:git/url url :git/sha sha}}))

   [#{:latest-sha} #{:git/url :latest-sha}]
   (fn [lib-sym lib-opts]
     (let [url (or (:git/url lib-opts) (github-repo-http-url lib-sym))
           sha (git/latest-github-sha (git-url->lib-sym url))]
       {lib-sym {:git/url url :git/sha sha}}))

   [#{:git/url :git/tag :git/sha}]
   (fn [lib-sym lib-opts]
     {lib-sym (select-keys lib-opts [:git/url :git/tag :git/sha])})})

(def valid-lib-opts
  "The set of all valid combinations of deps-new template deps opts."
  (into #{} cat (keys lib-opts->template-deps-fn)))

(defn- deps-new-cli-opts->lib-opts
  "Returns parsed deps-new template deps opts from raw CLI opts."
  [cli-opts]
  (-> cli-opts
      (set/rename-keys {:sha :git/sha})
      (select-keys (into #{} cat valid-lib-opts))))

(defn- invalid-lib-opts-error [provided-lib-opts]
  (ex-info (str "Provided invalid combination of CLI options for deps-new "
                "template deps.")
           {:provided-opts (set (keys provided-lib-opts))
            :valid-combinations valid-lib-opts}))

(defn- find-template-deps-fn
  "Returns a template-deps-fn given lib-opts parsed from raw CLI opts."
  [lib-opts]
  (some (fn [[k v]] (and (contains? (set k) (set (keys lib-opts))) v))
        lib-opts->template-deps-fn))

(defn- template-deps
  "Returns a tools.deps lib map for the given CLI opts."
  [template cli-opts]
  (let [lib-opts (deps-new-cli-opts->lib-opts cli-opts)
        lib-sym (edn/read-string template)
        template-deps-fn (find-template-deps-fn lib-opts)]
    (if-not template-deps-fn
      (throw (invalid-lib-opts-error lib-opts))
      (template-deps-fn lib-sym lib-opts))))

(def bb? (System/getProperty "babashka.version"))

(def create-opts-deny-list
  [:deps-file :dry-run :git/sha :git/url :latest-sha :local/root :sha])

(defn- cli-opts->create-opts
  "Returns options for org.corfield.new/create based on the cli-opts.

  If no template is provided, the scratch template is filled in.

  When using the scratch template, we also provide the :scratch create-opt as
  a default. This changes the default scratch.clj file and namespace to match
  the :name option instead."
  [cli-opts]
  (let [no-template (not (:template cli-opts))
        scratch-template (= (str (:template cli-opts)) "scratch")]
    (merge (when (or no-template scratch-template)
             {:template "scratch"
              :scratch (:name cli-opts)})
           (apply dissoc cli-opts create-opts-deny-list))))

(defn- deps-new-plan
  "Returns a plan for calling org.corfield.new/create.

  :template-deps - These deps will be added with babashka.deps/add-deps before
                   calling the create function.

  :create-opts   - This map contains the options that will be passed to the
                   create function."
  [cli-opts]
  (let [create-opts (cli-opts->create-opts cli-opts)
        tpl-deps (when (and bb? (not (built-in-template? (:template create-opts))))
                   (template-deps (:template create-opts) cli-opts))]
    (merge (when tpl-deps {:template-deps tpl-deps})
           {:create-opts create-opts})))

(defn- deps-new-create [create-opts]
  ((requiring-resolve 'org.corfield.new/create) create-opts))

(defn print-new-help []
  (println (str/trim "
Usage: neil new [template] [name] [target-dir] [options]

Runs the org.corfield.new/create function from deps-new.

All of the deps-new options can be provided as CLI options:

https://github.com/seancorfield/deps-new/blob/develop/doc/options.md

Both built-in and external templates are supported. Built-in templates use
unqualified names (e.g. scratch) whereas external templates use fully-qualified
names (e.g. io.github.kit/kit-clj).

If an external template is provided, the babashka.deps/add-deps function will be
called automatically before running org.corfield.new/create. The deps for the
template are inferred automatically from the template name. The following
options can be used to control the add-deps behavior:

  --local/root
    Override the :deps map to use the provided :local/root path.

  --git/url
    Override the :git/url in the :deps map. If no URL is provided, a template
    name starting with io.github or com.github is expected and the URL will
    point to GitHub.

  --git/tag
    Override the :git/tag in the :deps map. If no SHA or tag is provided, the
    latest tag from the default branch of :git/url will be used.

  --sha
  --git/sha
    Override the :git/sha in the :deps map. If no SHA or tag is provided, the
    latest tag from the default branch of :git/url will be used.

  --latest-sha
    Override the :git/sha in the :deps map with the latest SHA from the
    default branch of :git/url.")))

(defn- deps-new-set-classpath
  "Sets the java.class.path property.

  This is required by org.corfield.new/create. In Clojure it's set by default,
  but in Babashka it must be set explicitly."
  []
  (let [classpath ((requiring-resolve 'babashka.classpath/get-classpath))]
    (System/setProperty "java.class.path" classpath)))

(defn- deps-new-add-template-deps
  "Adds template deps at runtime."
  [template-deps]
  ((requiring-resolve 'babashka.deps/add-deps) {:deps template-deps}))

(defn run-deps-new
  "Runs org.corfield.new/create using the provided CLI options.

  To support the dry run feature, side-effects should be described in the plan
  provided by deps-new-plan. This function's job is to execute side-effects
  using the plan to provide repeatability."
  [{:keys [opts]}]
  (if (or (:help opts) (not (:name opts)))
    (print-new-help)
    (do
      (require 'org.corfield.new)
      (let [plan (deps-new-plan opts)
            {:keys [template-deps create-opts]} plan
            project-name (symbol (:name create-opts))
            dir (or (:target-dir create-opts)
                    (name project-name))]
        (if (:dry-run opts)
          (do (prn plan) nil)
          (do
            (when template-deps (deps-new-add-template-deps template-deps))
            (when bb? (deps-new-set-classpath))
            (deps-new-create create-opts)
            (proj/assoc-project-meta! (assoc opts :dir dir :k :name :v project-name))))))))

(ns babashka.neil.test
  (:require
   #?(:bb [babashka.deps :as deps])
   [babashka.fs :as fs]
   [babashka.process :refer [shell]]
   [clojure.edn :as edn]))

(def neil-test-spec {:dirs {:coerce []}
                     :nses {:coerce []}
                     :patterns {:coerce []}
                     :vars {:coerce []}
                     :only {:coerce :symbol}
                     :includes {:coerce []}
                     :excludes {:coerce []}})

(def neil-test-aliases
  {:dir :dirs
   :d :dirs
   :namespace :nses
   :n :nses
   :r :patterns
   :namespace-regex :patterns
   :v :vars
   :var :vars
   :include :includes
   :i :includes
   :exclude :includes
   :e :includes
   :H :test-help
   :help :test-help
   :h :test-help})

(defn clojure [& args]
  #?(:bb @(deps/clojure (vec args) {:inherit true})
     :clj (apply shell {} "bb clojure" args)))

(defn normalize-opts [opts]
  (if-let [only (:only opts)]
    (if (simple-symbol? only)
      (assoc opts :nses [only])
      (assoc opts :vars [only]))
    opts))

(defn neil-test [opts]
  (let [opts (normalize-opts opts)]
    (if (:test-help opts)
      (do
        (clojure "-M:test" "--test-help")
        (println)
        (println "Additional options supported by neil:")
        (println "  --only: a symbol denoting a var or namespace"))
      (let [deps-file (:deps-file opts)]
        (if (fs/exists? deps-file)
          (let [deps-edn (edn/read-string (slurp deps-file))]
            (if (some-> deps-edn :aliases :test)
              (clojure "-X:test" opts)
              (println "[neil] First execute: neil add test")))
          (println "[neil] Not inside a deps.edn project."))))))

(ns babashka.neil
  {:no-doc true}
  (:require
   [babashka.cli :as cli]
   [babashka.fs :as fs]
   [babashka.neil.curl :refer [curl-get-json url-encode]]
   [babashka.neil.git :as git]
   [babashka.neil.new :as new]
   [babashka.neil.project :as proj]
   [babashka.neil.rewrite :as rw]
   [babashka.neil.test :as neil-test]
   [borkdude.rewrite-edn :as r]
   [clojure.edn :as edn]
   [clojure.string :as str]))

(def spec {:lib {:desc "Fully qualified library name."}
           :version {:desc "Optional. When not provided, picks newest version from Clojars or Maven Central."}
           :sha {:desc "When provided, assumes lib refers to Github repo."}
           :latest-sha {:desc "When provided, assumes lib refers to Github repo and then picks latest SHA from it."}
           :deps/root {:desc "Sets deps/root to give value."}
           :as {:desc "Use as dependency name in deps.edn"
                :coerce :symbol}
           :alias {:ref "<alias>"
                   :desc "Add to alias <alias>."
                   :coerce :keyword}
           :deps-file {:ref "<file>"
                       :desc "Add to <file> instead of deps.edn."
                       :default "deps.edn"}
           :limit {:coerce :long}})

(def version "0.1.43")

(def windows? (fs/windows?))

(def bb? (System/getProperty "babashka.version"))

(defn- get-clojars-artifact [qlib]
  (curl-get-json
   (format "https://clojars.org/api/artifacts/%s"
           qlib)))

(defn latest-clojars-version [qlib]
  (get (get-clojars-artifact qlib) :latest_release))

(defn clojars-versions [qlib {:keys [limit] :or {limit 10}}]
  (let [body (get-clojars-artifact qlib)]
    (->> body
         :recent_versions
         (map :version)
         (take limit))))

(defn- search-mvn [qlib limit]
  (:response
   (curl-get-json
    (format "https://search.maven.org/solrsearch/select?q=g:%s+AND+a:%s&rows=%s"
            (namespace qlib)
            (name qlib)
            (str limit)))))

(defn latest-mvn-version [qlib]
  (-> (search-mvn qlib 1)
      :docs
      first
      :latestVersion))

(defn mvn-versions [qlib {:keys [limit] :or {limit 10}}]
  (let [payload (search-mvn qlib limit)]
    (->> payload
         :docs
         (map :v))))

(def deps-template
  (str/triml "
{:deps {}
 :aliases {}}
"))

(def bb-template
  (str/triml "
{:deps {}
 :tasks
 {
 }}
"))

(defn ensure-deps-file [opts]
  (let [target (:deps-file opts)]
    (when-not (fs/exists? target)
      (spit target (if (= "bb.edn" target)
                     bb-template
                     deps-template)))))

(defn edn-string [opts] (slurp (:deps-file opts)))

(defn edn-nodes [edn-string] (r/parse-string edn-string))

(def cognitect-test-runner-alias
  "
{:extra-paths [\"test\"]
 :extra-deps {io.github.cognitect-labs/test-runner
               {:git/tag \"v0.5.0\" :git/sha \"b3fd0d2\"}}
 :main-opts [\"-m\" \"cognitect.test-runner\"]
 :exec-fn cognitect.test-runner.api/test}")

(defn add-alias [opts alias-kw alias-contents]
  (ensure-deps-file opts)
  (let [edn-string (edn-string opts)
        edn-nodes (edn-nodes edn-string)
        edn (edn/read-string edn-string)
        alias (or (:alias opts)
                  alias-kw)
        existing-aliases (get-in edn [:aliases])
        alias-node (r/parse-string
                    (str (when (seq existing-aliases) "\n ")
                         alias
                         " ;; added by neil"))]
    (if-not (get existing-aliases alias)
      (let [s (-> (if-not (seq existing-aliases)
                                        ; If there are no existing aliases, we assoc an empty map
                                        ; before updating to prevent borkdude.rewrite-edn/update
                                        ; from removing the newline preceding the :aliases key.
                    (r/assoc edn-nodes :aliases {})
                    edn-nodes)
                  (r/update :aliases
                            (fn [aliases]
                              (let [s (rw/indent alias-contents 1)
                                    alias-nodes (r/parse-string s)
                                    aliases' (r/assoc aliases alias-node alias-nodes)]
                                (if-not (seq existing-aliases)
                                        ; If there are no existing aliases, add an
                                        ; explicit newline after the :aliases key.
                                  (r/parse-string (str "\n" (rw/indent (str aliases') 1)))
                                  aliases'))))

                  str)
            s (rw/clean-trailing-whitespace s)
            s (str s "\n")]
        (spit (:deps-file opts) s))
      (do (println (format "[neil] Project deps.edn already contains alias %s" (str alias ".")))
          ::update))))

(declare print-help)

(defn add-cognitect-test-runner [{:keys [opts] :as cmd}]
  (if (:help opts)
    (print-help cmd)
    (do (add-alias opts :test cognitect-test-runner-alias)

        (when-let [pn (proj/project-name opts)]
          (let [test-ns (symbol (str (str/replace pn "/" ".") "-test"))
                test-path (-> (str test-ns)
                              (str/replace "-" "_")
                              (str/replace "." fs/file-separator)
                              (str ".clj"))
                test-path (fs/file "test" test-path)]
            (when (or (not (fs/exists? "test"))
                      (zero? (count (fs/list-dir "test"))))
              (fs/create-dirs (fs/parent test-path))
              (spit test-path
                    (format "(ns %s
  (:require [clojure.test :as t :refer [deftest is testing]]))

(deftest %s-test
  (testing \"TODO: fix\"
    (is (= :foo :bar))))
" test-ns (name pn)))))))))

(def kaocha-alias
  "
{:extra-deps {lambdaisland/kaocha {:mvn/version \"1.0.887\"}}}")

(defn add-kaocha [{:keys [opts] :as cmd}]
  (if (:help opts)
    (print-help cmd)
    (add-alias opts :kaocha kaocha-alias)))

(defn nrepl-alias []
  (format "
{:extra-deps {nrepl/nrepl {:mvn/version \"%s\"}}
 :main-opts [\"-m\" \"nrepl.cmdline\" \"--interactive\" \"--color\"]}"
          (latest-clojars-version 'nrepl/nrepl)))

(defn add-nrepl [{:keys [opts] :as cmd}]
  (if (:help opts)
    (print-help cmd)
    (add-alias opts :nrepl (nrepl-alias))))

(defn build-alias [_opts]
  (let [latest-tag (git/latest-github-tag 'clojure/tools.build)
        tag (:name latest-tag)
        sha (-> latest-tag :commit :sha (subs 0 7))
        s (format "
{:deps {io.github.clojure/tools.build {:git/tag \"%s\" :git/sha \"%s\"}
        slipset/deps-deploy {:mvn/version \"0.2.0\"}}
 :ns-default build}"
                  tag sha)]
    {:s s
     :tag tag
     :sha sha}))

(defn build-file
  [_opts]
  (let [base "(ns build
  (:require [clojure.tools.build.api :as b]
            [clojure.edn :as edn]))

(def project (-> (edn/read-string (slurp \"deps.edn\"))
                 :aliases :neil :project))
(def lib (or (:name project) 'my/lib1))

;; use neil project set version 1.2.0 to update the version in deps.edn

(def version (or (:version project)
                 \"1.2.0\"))
(def class-dir \"target/classes\")
(def basis (b/create-basis {:project \"deps.edn\"}))
(def uber-file (format \"target/%s-%s-standalone.jar\" (name lib) version))
(def jar-file (format \"target/%s-%s.jar\" (name lib) version))

(defn clean [_]
  (b/delete {:path \"target\"}))

(defn jar [_]
  (b/write-pom {:class-dir class-dir
                :lib lib
                :version version
                :basis basis
                :src-dirs [\"src\"]})
  (b/copy-dir {:src-dirs [\"src\" \"resources\"]
               :target-dir class-dir})
  (b/jar {:class-dir class-dir
          :jar-file jar-file}))

(defn install [_]
  (jar {})
  (b/install {:basis basis
              :lib lib
              :version version
              :jar-file jar-file
              :class-dir class-dir}))

(defn uber [_]
  (clean nil)
  (b/copy-dir {:src-dirs [\"src\" \"resources\"]
               :target-dir class-dir})
  (b/compile-clj {:basis basis
                  :src-dirs [\"src\"]
                  :class-dir class-dir})
  (b/uber {:class-dir class-dir
           :uber-file uber-file
           :basis basis}))

(defn deploy [opts]
  (jar opts)
  ((requiring-resolve 'deps-deploy.deps-deploy/deploy)
    (merge {:installer :remote
                       :artifact jar-file
                       :pom-file (b/pom-path {:lib lib :class-dir class-dir})}
                    opts))
  opts)

"]
    base))

(defn add-build [{:keys [opts] :as cmd}]
  (if (:help opts)
    (print-help cmd)
    (do
      (if-not (fs/exists? "build.clj")
        (spit "build.clj" (build-file opts))
        (println "[neil] Project build.clj already exists."))
      (ensure-deps-file opts)
      (let [ba (build-alias opts)]
        (when (= ::update (add-alias opts :build (:s ba)))
          (println "[neil] Updating tools build to newest git tag + sha.")
          (let [edn-string (edn-string opts)
                edn (edn/read-string edn-string)
                build-alias (get-in edn [:aliases :build :deps 'io.github.clojure/tools.build])
                [tag-key sha-key]
                (cond (and
                       (:tag build-alias)
                       (:sha build-alias))
                      [:tag :sha]
                      (and
                       (:git/tag build-alias)
                       (:git/sha build-alias))
                      [:git/tag :git/sha])]
            (when (and tag-key sha-key)
              (let [nodes (edn-nodes edn-string)
                    nodes (r/assoc-in nodes [:aliases :build :deps 'io.github.clojure/tools.build tag-key]
                                      (:tag ba))
                    nodes (r/assoc-in nodes [:aliases :build :deps 'io.github.clojure/tools.build sha-key]
                                      (:sha ba))
                    s (str (str/trim (str nodes)) "\n")]
                (spit (:deps-file opts) s)))))))))

(defn print-dep-add-help []
  (println "Usage: neil add dep [lib] [options]")
  (println "Options:")
  (println (cli/format-opts
            {:spec spec
             :order [:lib :version :sha :latest-sha :deps/root :as :alias :deps-file]})))

(defn dep-add [{:keys [opts]}]
  (if (:help opts)
    (print-dep-add-help)
    (do
      (ensure-deps-file opts)
      (let [edn-string (edn-string opts)
            edn-nodes (edn-nodes edn-string)
            lib (:lib opts)
            lib (symbol lib)
            explicit-git? (or (:sha opts)
                              (:latest-sha opts))
            [version git?] (if explicit-git?
                             [(or (:sha opts)
                                  (git/latest-github-sha lib)) true]
                             (or
                              (when-let [v (:version opts)]
                                [v false])
                              (when-let [v (latest-clojars-version lib)]
                                [v false])
                              (when-let [v (latest-mvn-version lib)]
                                [v false])
                              (when-let [v (git/latest-github-sha lib)]
                                [v true])))
            mvn? (not git?)
            git-url (when git?
                      (or (:git/url opts)
                          (str "https://github.com/" (git/clean-github-lib lib))))
            as (or (:as opts) lib)
            ;; force newline
            edn-nodes (-> edn-nodes (r/assoc-in [:deps as] nil) str r/parse-string)
            nodes (cond
                    mvn?
                    (r/assoc-in edn-nodes [:deps as]
                                {:mvn/version version})
                    git?
                    ;; multiple steps to force newlines
                    (-> edn-nodes
                        (r/assoc-in
                         [:deps as :git/url] git-url)
                        str
                        r/parse-string
                        (r/assoc-in
                         [:deps as :git/sha] version)))
            nodes (if-let [root (and git? (:deps/root opts))]
                    (-> nodes
                        (r/assoc-in [:deps as :deps/root] root))
                    nodes)
            s (str (str/trim (str nodes)) "\n")]
        (spit (:deps-file opts) s)))))

(defn dep-versions [{:keys [opts]}]
  (let [lib (:lib opts)
        lib (symbol lib)
        versions (or (seq (clojars-versions lib opts))
                     (seq (mvn-versions lib opts)))]
    (if-not versions
      (binding [*out* *err*]
        (println "Unable to find" lib "on Clojars or Maven.")
        (System/exit 1))
      (doseq [v versions]
        (println :lib lib :version v)))))

(defn print-dep-search-help []
  (println (str/trim "
Usage: neil dep search [lib]

Search Clojars for a string in any attribute of an artifact:

  $ neil dep search \"babashka.nrepl\"
  :lib babashka/babashka.nrepl :version 0.0.6

Note that Clojars stores the namespace and name of a library as separate
attributes, so searching for a ns-qualified library will not necessarily
return any matches:

  $ neil dep search \"babashka/babashka.nrepl\"
  Unable to find babashka/babashka.nrepl on Clojars.

But a search string can be matched in a library's description:

$ neil dep search \"test framework\"

will return libraries with 'test framework' in their description.")))

(defn dep-search [{:keys [opts]}]
  (if (or (:help opts) (not (:search-term opts)))
    (print-dep-search-help)
    (let [search-term (:search-term opts)
          url (str "https://clojars.org/search?format=json&q=\"" (url-encode search-term) "\"")
          {search-results :results
           results-count :count} (curl-get-json url)]
      (when (zero? results-count)
        (binding [*out* *err*]
          (println "Unable to find" search-term  "on Clojars.")
          (System/exit 1)))
      (doseq [search-result search-results]
        (println :lib (format  "%s/%s"
                               (:group_name search-result)
                               (:jar_name search-result))
                 :version (:version search-result)
                 :description (pr-str (:description search-result)))))))

(defn print-help [_]
  (println (str/trim "
Usage: neil <subcommand> <options>

Most subcommands support the options:
  --alias      Override alias name.
  --deps-file  Override deps.edn file name.

Subcommands:

add
  dep    Alias for `neil dep add`.
  test   adds cognitect test runner to :test alias.
  build  adds tools.build build.clj file and :build alias.
  kaocha adds kaocha test runner to :koacha alias.
  nrepl  adds nrepl server to :nrepl alias.

dep
  add: Adds --lib, a fully qualified symbol, to deps.edn :deps.
    Run neil dep add --help to see all options.

new:
  Create a project using deps-new
    Run neil new --help to see all options.

  Examples:
    neil new scratch foo --overwrite
    neil new io.github.rads/neil-new-test-template foo2 --latest-sha

test:
  Run tests. Assumes `neil add test`. Run `neil test --help` to see all options.

license
  list   Lists commonly-used licenses available to be added to project. Takes an optional search string to filter results.
  search Alias for `list`
  add    Writes license text to a file
    Options:
    --license The key of the license to use (e.g. epl-1.0, mit, unlicense). --license option name may be elided when license key is provided as first argument.
    --file    The file to write. Defaults to 'LICENSE'.
")))

;; licenses
(def licenses-api-url "https://api.github.com/licenses")

(defn license-search [{:keys [opts]}]
  (let [search-term (:search-term opts)
        license-vec (->> (str licenses-api-url "?per_page=50")
                         curl-get-json
                         (map #(select-keys % [:key :name])))
        search-results (if search-term
                         (filter #(str/includes?
                                   (str/lower-case (:name %))
                                   (str/lower-case search-term))
                                 license-vec)
                         license-vec)]
    (if (empty? search-results)
      (binding [*out* *err*]
        (println "No licenses found")
        (System/exit 1))
      (doseq [result search-results]
        (println :license (:key result) :name (pr-str (:name result)))))))

(defn license-to-file [{:keys [opts]}]
  (let [license-key (:license opts)
        output-file (or (:file opts) "LICENSE")
        {:keys [message name body]} (some->> license-key url-encode
                                             (str licenses-api-url "/")
                                             curl-get-json)]
    (cond
      (not license-key) (throw (ex-info "No license key provided." {}))
      (= message "Not Found")
      (throw (ex-info (format "License '%s' not found." license-key) {:license license-key}))
      (not body)
      (throw (ex-info (format "License '%s' has no body text." (or name license-key))
                      {:license license-key}))
      :else (spit output-file body))))

(defn add-license [opts]
  (try
    (license-to-file opts)
    (catch Exception e
      (binding [*out* *err*]
        (println (ex-message e))
        (System/exit 1)))))

(defn neil-test [{:keys [opts]}]
  (neil-test/neil-test opts))

(defn print-version [_]
  (println "neil" version))

(defn -main [& _args]
  (cli/dispatch
   [{:cmds ["add" "dep"] :fn dep-add :args->opts [:lib]}
    {:cmds ["add" "test"] :fn add-cognitect-test-runner}
    {:cmds ["add" "build"] :fn add-build}
    {:cmds ["add" "kaocha"] :fn add-kaocha}
    {:cmds ["add" "nrepl"] :fn add-nrepl}
    {:cmds ["dep" "versions"] :fn dep-versions :args->opts [:lib]}
    {:cmds ["dep" "add"] :fn dep-add :args->opts [:lib]}
    {:cmds ["dep" "search"] :fn dep-search :args->opts [:search-term]}
    {:cmds ["license" "list"] :fn license-search :args->opts [:search-term]}
    {:cmds ["license" "search"] :fn license-search :args->opts [:search-term]}
    {:cmds ["license" "add"] :fn add-license :args->opts [:license]}
    {:cmds ["new"] :fn new/run-deps-new
     :args->opts [:template :name :target-dir]
     :spec {:name {:coerce proj/coerce-project-name}}}
    {:cmds ["version"] :fn print-version}
    {:cmds ["help"] :fn print-help}
    {:cmds ["test"] :fn neil-test
     ;; TODO: babashka CLI doesn't support :coerce option directly here
     :spec neil-test/neil-test-spec
     :alias neil-test/neil-test-aliases}
    {:cmds [] :fn (fn [{:keys [opts] :as m}]
                    (if (:version opts)
                      (print-version m)
                      (print-help m)))}]
   *command-line-args*
   {:spec spec
    :exec-args {:deps-file "deps.edn"}})
  nil)

(when (= *file* (System/getProperty "babashka.file"))
  (-main))
